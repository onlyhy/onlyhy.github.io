<!DOCTYPE html>
<html lang="zh-cn">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="OnlyHy">
    <meta name="description" content="网络请求    Fetch    典型的fetch请求：
 let response = await fetch(url, [options]) // 解析 response header let result = await response.json(); // 将 body 读取为 json 或以Promise形式： fetch(url, options) .then(response =&gt; response.json()) .then(result =&gt; /* process result */)  响应的属性：
  response.status —— response 的 HTTP 状态码， response.ok —— HTTP 状态码为 200-299，则为 true。 response.headers —— 类似于 Map 的带有 HTTP header 的对象。   获取response body：">
    <meta name="keywords" content="onlyhy">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="现代JS教程[第三部分（二）]"/>
<meta name="twitter:description" content="网络请求    Fetch    典型的fetch请求：
 let response = await fetch(url, [options]) // 解析 response header let result = await response.json(); // 将 body 读取为 json 或以Promise形式： fetch(url, options) .then(response =&gt; response.json()) .then(result =&gt; /* process result */)  响应的属性：
  response.status —— response 的 HTTP 状态码， response.ok —— HTTP 状态码为 200-299，则为 true。 response.headers —— 类似于 Map 的带有 HTTP header 的对象。   获取response body："/>

    <meta property="og:title" content="现代JS教程[第三部分（二）]" />
<meta property="og:description" content="网络请求    Fetch    典型的fetch请求：
 let response = await fetch(url, [options]) // 解析 response header let result = await response.json(); // 将 body 读取为 json 或以Promise形式： fetch(url, options) .then(response =&gt; response.json()) .then(result =&gt; /* process result */)  响应的属性：
  response.status —— response 的 HTTP 状态码， response.ok —— HTTP 状态码为 200-299，则为 true。 response.headers —— 类似于 Map 的带有 HTTP header 的对象。   获取response body：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://onlyhy.github.io/posts/2021-12-19-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E4%BA%8C/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-19T09:00:00+08:00" />
<meta property="article:modified_time" content="2021-12-19T09:00:00+08:00" />



    <title>
  现代JS教程[第三部分（二）] · oooonlyhy
</title>

    
      <link rel="canonical" href="http://onlyhy.github.io/posts/2021-12-19-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E4%BA%8C/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css" integrity="sha256-2f3b/&#43;byfmmYXcX&#43;BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin="anonymous" media="screen" />
    

    

    

    

    

    <link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.91.0" />
  </head>

  
  
  <body class="preload-transitions colorscheme-light">
    

    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      oooonlyhy
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/">首页</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">归档</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/categories/">分类</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于我</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://onlyhy.github.io/posts/2021-12-19-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E4%BA%8C/">
              现代JS教程[第三部分（二）]
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2021-12-19T09:00:00&#43;08:00'>
                December 19, 2021
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              阅读时间：3 分钟
            </span>
          </div>
          <div class="authors">
    <i class="fa fa-user" aria-hidden="true"></i>
      <a href="/authors/onlyhy/">onlyhy</a></div>
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B/">现代JS教程</a></div>

          
        </div>
      </header>

      <div>
        
        <h3 id="网络请求httpszhjavascriptinfonetwork">
  <a href="https://zh.javascript.info/network">网络请求</a>
  <a class="heading-link" href="#%e7%bd%91%e7%bb%9c%e8%af%b7%e6%b1%82httpszhjavascriptinfonetwork">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h5 id="fetch">
  Fetch
  <a class="heading-link" href="#fetch">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>典型的fetch请求：</p>
<ol>
<li><code>let response = await fetch(url, [options]) // 解析 response header</code></li>
<li><code>let result = await response.json(); // 将 body 读取为 json</code>
或以Promise形式：
<code>fetch(url, options) .then(response =&gt; response.json()) .then(result =&gt; /* process result */)</code></li>
</ol>
<p>响应的属性：</p>
<blockquote>
<ul>
<li>response.status —— response 的 HTTP 状态码，</li>
<li>response.ok —— HTTP 状态码为 200-299，则为 true。</li>
<li>response.headers —— 类似于 Map 的带有 HTTP header 的对象。</li>
</ul>
</blockquote>
<p>获取response body：</p>
<blockquote>
<ul>
<li>response.text() —— 读取 response，并以文本形式返回 response，</li>
<li>response.json() —— 将 response 解析为 JSON 对象形式，</li>
<li>response.formData() —— 以 FormData 对象（form/multipart 编码，参见下一章）的形式返回 response，</li>
<li>response.blob() —— 以 Blob（具有类型的二进制数据）形式返回 response，</li>
<li>response.arrayBuffer() —— 以 ArrayBuffer（低级别的二进制数据）形式返回 response。</li>
</ul>
</blockquote>
<p>fetch的选项：</p>
<blockquote>
<ul>
<li>method —— HTTP 方法，</li>
<li>headers —— 具有 request header 的对象（不是所有 header 都是被允许的）</li>
<li>body —— 要以 string，FormData，BufferSource，Blob 或 UrlSearchParams 对象的形式发送的数据（request body）。</li>
</ul>
</blockquote>
<h5 id="formdata">
  FormData
  <a class="heading-link" href="#formdata">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p><code>let formData = new FormData([form]);</code>
FormData对象作为body，带有 Content-Type: multipart/form-data。
可以发送带有文件的表单、具有Blob数据的表单</p>
<p>既可以从HTML表单创建new FormData(form)，也可以创建一个没有表单的 new FormData()接着去附加字段：</p>
<blockquote>
<ul>
<li>formData.append(name, value)</li>
<li>formData.append(name, blob, fileName)</li>
<li>formData.set(name, value)</li>
<li>formData.set(name, blob, fileName)</li>
<li>formData.delete(name)</li>
<li>formData.get(name)</li>
<li>formData.has(name)</li>
</ul>
</blockquote>
<blockquote>
<p>set方法会移除具有相同名称(name)的字段，而append不会</p>
</blockquote>
<h5 id="fetch下载进度">
  Fetch：下载进度
  <a class="heading-link" href="#fetch%e4%b8%8b%e8%bd%bd%e8%bf%9b%e5%ba%a6">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>使用<code>response.body</code>属性，它是<strong>ReadableStream</strong>，可以逐块(chunk)的提供body。
<code>const reader = response.body.getReader();</code>
<code>const {done, value} = await reader.read();</code></p>
<blockquote>
<p>done： 当读取完成时为 true，否则为 false。
value：字节的类型化数组：Uint8Array。
循环中接收chunk直到done为true</p>
</blockquote>
<blockquote>
<p>进度：接收到的value的length的和 与 response.headers.get(&lsquo;Content-Length&rsquo;)相比</p>
</blockquote>
<p>最后根据具体情况使用chunks创建一个Blob或者合并Chunks：response.headers.get(&lsquo;Content-Length&rsquo;)&hellip;等</p>
<h5 id="fetch中止abort">
  Fetch：中止（Abort）
  <a class="heading-link" href="#fetch%e4%b8%ad%e6%ad%a2abort">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>内建对象：<strong>AbortController</strong>可以终止fetch，当abort() 方法被调用时，会在自身的 signal 属性上生成 abort 事件（并将 signal.aborted 设置为 true）。</p>
<p>将 <strong><code>signal</code>属性</strong> 作为可选参数在fetch中传递，fetch会监听它的值，为true则终止请求，fetch的promise会以一个 error <strong>AbortError</strong> reject，可以在try..catch中处理</p>
<p>AbortController可以一次取消多个fetch</p>
<h5 id="fetch跨源请求">
  Fetch：跨源请求
  <a class="heading-link" href="#fetch%e8%b7%a8%e6%ba%90%e8%af%b7%e6%b1%82">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>两种类型的跨源请求：</p>
<ol>
<li>简单的请求</li>
<li>所有其他请求</li>
</ol>
<p><strong>简单的请求：</strong></p>
<ol>
<li>简单的方法：GET,POST,HEAD</li>
<li>简单的header：
<ul>
<li>Accept</li>
<li>Accept-Language，</li>
<li>Content-Language，</li>
<li>Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain。</li>
</ul>
</li>
</ol>
<blockquote>
<ol>
<li>跨源的请求中，浏览器会始终添加 <code>Origin</code> header，包含确切的源（domain/protocol/port），没有路径。</li>
<li>服务器检查 <code>Origin</code>，如果同意接受请求，在响应中添加<code>Access-Control-Allow-Origin</code> header，该header包含允许的源或者一个星号 * 。</li>
</ol>
</blockquote>
<p><img src="evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1072" alt="f1cbdac01c13a7b79d480abb5fbb27c7.png"></p>
<blockquote>
<ol>
<li>默认情况下，跨源请求只能访问“简单”response header：
Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。访问其它的会导致error。</li>
<li>想要访问其它response header，需要服务端发送<code>Access-Control-Expose-Headers</code>header，包含一个以逗号分隔的应该被设置为可访问的非简单 header 名称列表。如：<code>Access-Control-Expose-Headers: Content-Length,xxx</code></li>
</ol>
</blockquote>
<p><strong>非简单的请求：</strong>
对于非简单请求，浏览器都会在发送请求前进行 <strong>“预检(preflight)”</strong> 请求来请求许可。</p>
<ol>
<li>预检请求使用<code>OPTIONS</code>方法，没有body，有两个header：</li>
</ol>
<ul>
<li><code>Access-Control-Request-Method </code> header带有非简单请求的方法</li>
<li><code>Access-Control-Request-Headers</code> header提供一个以逗号分隔的非简单 HTTP-header 列表</li>
</ul>
<ol start="2">
<li>如果服务器同意，状态码返回200，没有body，有header：</li>
</ol>
<ul>
<li><code>Access-Control-Allow-Origin</code> 必须为 * 或进行请求的源（例如 <a href="https://javascript.info">https://javascript.info</a>）才能允许此请求。</li>
<li><code>Access-Control-Allow-Methods</code> 必须具有允许的方法。</li>
<li><code>Access-Control-Allow-Headers</code> 必须具有一个允许的 header 列表。</li>
<li><code>Access-Control-Max-Age</code> 可以指定缓存此权限的秒数。因此，浏览器不是必须为满足给定权限的后续请求发送预检。
<img src="evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1073" alt="25d315392e30f7c4b19530a01e6896c4.png"></li>
</ul>
<p><strong>凭据（Credentials）</strong>
默认情况，跨源请求不会带来任何凭据（cookies或HTTP认证），因为具有凭据的请求比没有凭据的请求要强大得多，如果被允许，它会使用它们的凭据授予 JavaScript 代表用户行为和访问敏感信息的全部权力。</p>
<p>如果要在fetch中发送凭据：要添加<code>credentials: &quot;include&quot;</code>选项；
如果服务器同意，则除了<code>Access-Control-Allow-Origin</code> 外，服务器还应该在响应中添加 header <code>Access-Control-Allow-Credentials: true</code>。（ <strong>且对于有凭据的请求，<code>Access-Control-Allow-Origin</code>必须是一个确切的源而不能是 星号</strong>* ）</p>
<h5 id="fetch-api">
  Fetch API
  <a class="heading-link" href="#fetch-api">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p><a href="https://zh.javascript.info/fetch-api">API</a></p>
<h5 id="url-对象">
  URL 对象
  <a class="heading-link" href="#url-%e5%af%b9%e8%b1%a1">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p><code>new URL(url, [base])</code></p>
<ul>
<li>url  完整的 URL，或者仅路径（如果设置了 base）</li>
<li>base  可选的 base URL：如果设置了此参数，且参数 url 只有路径，则会根据这个 base 生成 URL
<img src="evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1074" alt="e22b5385225219cd9beb65fdfe49d221.png"></li>
</ul>
<p><code>url.searchParams</code>用于为搜索参数提供方法</p>
<p>URL对象对于不允许的字符会自动编码(encoding)</p>
<p><strong>编码字符串</strong>
如果使用字符串，则需要手动编码/解码特殊字符。</p>
<ul>
<li>encodeURI —— 编码整个 URL。（<strong>仅编码 URL 中完全禁止的字符</strong>）</li>
<li>decodeURI —— 解码为编码前的状态。</li>
<li>encodeURIComponent —— 编码 URL 组件，例如搜索参数，或者 hash，或者 pathname。（<strong>不仅编码 URL 中完全禁止的字符，此外，还编码 #，$，&amp;，+，,，/，:，;，=，? 和 @ 字符</strong>）</li>
<li>decodeURIComponent —— 解码为编码前的状态</li>
</ul>
<h5 id="xmlhttprequest">
  XMLHttpRequest
  <a class="heading-link" href="#xmlhttprequest">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p><strong><code>XMLHttpRequest</code></strong> 是一个内建的浏览器对象，它允许使用 JavaScript 发送 HTTP 请求。</p>
<p>需要做一些 fetch 目前无法做到的事情，例如跟踪上传进度</p>
<p>两种执行模式：同步（synchronous）和异步（asynchronous）
<strong>异步请求：</strong></p>
<ol>
<li>创建 <code>let xhr = new XMLHttpRequest();</code></li>
<li>初始化 <code>xhr.open(method, URL, [async, user, password])</code>，不会建立连接，仅配置请求</li>
<li>发送请求 <code>xhr.send([body])</code>，建立连接，将请求发送到服务器</li>
<li>监听xhr事件
<ul>
<li>load 请求完成</li>
<li>error 无法发出请求</li>
<li>progress 在下载响应期间定期触发，报告已经下载了多少（<code>event.loaded</code>——已经下载了多少字节，<code>event.lengthComputable = true</code>——当服务器发送了 Content-Length header 时，<code>event.total</code>——总字节数（如果 lengthComputable 为 true））</li>
<li>loadstart 请求开始</li>
<li>abort 调用 xhr.abort() 取消了请求，触发 abort 事件，且 xhr.status 变为 0</li>
<li>timeout 由于请求超时而取消了该请求（仅发生在设置了 timeout 的情况下）</li>
<li>loadend 在 load，error，timeout 或 abort 之后触发。</li>
</ul>
</li>
</ol>
<p>xhr属性：</p>
<ul>
<li>status HTTP 状态码</li>
<li>statusText HTTP 状态消息</li>
<li>response 服务器 response body</li>
<li>timeout 超时时间，单位ms</li>
<li>responseType 默认为字符串，还可以为text，arraybuffer，blob,document,json</li>
<li>readyState 可以使用readystatechange 事件来跟踪：
<ul>
<li>UNSENT = 0; // 初始状态</li>
<li>OPENED = 1; // open 被调用</li>
<li>HEADERS_RECEIVED = 2; // 接收到 response header</li>
<li>LOADING = 3; // 响应正在被加载（接收到一个数据包）</li>
<li>DONE = 4; // 请求完成</li>
</ul>
</li>
</ul>
<p><strong>同步请求：</strong>
在 open 方法中将第三个参数 async 设置为 false</p>
<p><strong>HTTP-header：</strong>
XMLHttpRequest 允许发送自定义 header，并且可以从响应中读取 header。</p>
<ol>
<li><code>setRequestHeader(name, value)</code></li>
<li><code>getResponseHeader(name)</code></li>
<li><code>getAllResponseHeaders()</code></li>
</ol>
<p><strong>上传进度：</strong>
<code>progress</code> 事件仅在<strong>下载阶段</strong>触发。
<strong><code>xhr.upload</code></strong> 专门用于跟踪<strong>上传事件</strong>。
<code>xhr.upload</code>事件：</p>
<ul>
<li>loadstart —— 上传开始。</li>
<li>progress —— 上传期间定期触发。</li>
<li>abort —— 上传中止。</li>
<li>error —— 非 HTTP 错误。</li>
<li>load —— 上传成功完成。</li>
<li>timeout —— 上传超时（如果设置了 timeout 属性）。</li>
<li>loadend —— 上传完成，无论成功还是 error。</li>
</ul>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    ©
    
      2017 -
    
    2021
     OnlyHy 
    ·
    技术支持 <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

    </main>

    
      
      <script src="/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js" integrity="sha256-A7F3afT5GuNWZ&#43;HyocqMFvUFYlds&#43;Q/zKzF5kmkU2qU="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
