<!DOCTYPE html>
<html lang="zh-cn">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="OnlyHy">
    <meta name="description" content="Frame和window    弹窗和 window 的方法    阻止弹窗：如果弹窗是在用户触发的事件处理程序（如 onclick）之外调用的，大多数浏览器都会阻止此类弹窗。
如果弹窗是从 onclick 打开的，但是在 setTimeout 之后，弹窗在 Chrome 中会被打开，但是在 Firefox 中会被阻止。（Firefox 可以接受 2000ms 或更短的延迟）。
window.open(url, name, params)
 open调用会返回对新窗口的引用，可以用来操纵属性，修改内容等。 弹窗也可以使用window.opener来访问opener窗口（打开弹窗的窗口）。 因此窗口之间的连接是双向的：主窗口和弹窗之间相互引用。  xxx.close()关闭一个弹窗 xxx.closed检查窗口是否被关闭
focus/blur事件可以跟踪窗口的切换
跨窗口通信    同源：协议、域、端口都相同 非同源：无法访问该窗口中的内容，唯一例外是可以修改location但是无法读取location
iframe window：iframe.contentWindow document：iframe.contentDocument(iframe.contentWindow.document的简写)
 不要对尚未加载完成的 iframe 的文档进行处理，因为那是 错误的文档不同于加载到其中的文档。
 获取&lt;iframe&gt;的window对象：
 通过索引获取：window.frames[0] —— 文档中的第一个 iframe 的 window 对象。 通过名称获取：window.frames.iframeName —— 获取 name=&ldquo;iframeName&rdquo; 的 iframe 的 window 对象。  iframe可以嵌套，相应的window对象会形成一个层次结构">
    <meta name="keywords" content="onlyhy">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="现代JS教程[第三部分其他（一）]"/>
<meta name="twitter:description" content="Frame和window    弹窗和 window 的方法    阻止弹窗：如果弹窗是在用户触发的事件处理程序（如 onclick）之外调用的，大多数浏览器都会阻止此类弹窗。
如果弹窗是从 onclick 打开的，但是在 setTimeout 之后，弹窗在 Chrome 中会被打开，但是在 Firefox 中会被阻止。（Firefox 可以接受 2000ms 或更短的延迟）。
window.open(url, name, params)
 open调用会返回对新窗口的引用，可以用来操纵属性，修改内容等。 弹窗也可以使用window.opener来访问opener窗口（打开弹窗的窗口）。 因此窗口之间的连接是双向的：主窗口和弹窗之间相互引用。  xxx.close()关闭一个弹窗 xxx.closed检查窗口是否被关闭
focus/blur事件可以跟踪窗口的切换
跨窗口通信    同源：协议、域、端口都相同 非同源：无法访问该窗口中的内容，唯一例外是可以修改location但是无法读取location
iframe window：iframe.contentWindow document：iframe.contentDocument(iframe.contentWindow.document的简写)
 不要对尚未加载完成的 iframe 的文档进行处理，因为那是 错误的文档不同于加载到其中的文档。
 获取&lt;iframe&gt;的window对象：
 通过索引获取：window.frames[0] —— 文档中的第一个 iframe 的 window 对象。 通过名称获取：window.frames.iframeName —— 获取 name=&ldquo;iframeName&rdquo; 的 iframe 的 window 对象。  iframe可以嵌套，相应的window对象会形成一个层次结构"/>

    <meta property="og:title" content="现代JS教程[第三部分其他（一）]" />
<meta property="og:description" content="Frame和window    弹窗和 window 的方法    阻止弹窗：如果弹窗是在用户触发的事件处理程序（如 onclick）之外调用的，大多数浏览器都会阻止此类弹窗。
如果弹窗是从 onclick 打开的，但是在 setTimeout 之后，弹窗在 Chrome 中会被打开，但是在 Firefox 中会被阻止。（Firefox 可以接受 2000ms 或更短的延迟）。
window.open(url, name, params)
 open调用会返回对新窗口的引用，可以用来操纵属性，修改内容等。 弹窗也可以使用window.opener来访问opener窗口（打开弹窗的窗口）。 因此窗口之间的连接是双向的：主窗口和弹窗之间相互引用。  xxx.close()关闭一个弹窗 xxx.closed检查窗口是否被关闭
focus/blur事件可以跟踪窗口的切换
跨窗口通信    同源：协议、域、端口都相同 非同源：无法访问该窗口中的内容，唯一例外是可以修改location但是无法读取location
iframe window：iframe.contentWindow document：iframe.contentDocument(iframe.contentWindow.document的简写)
 不要对尚未加载完成的 iframe 的文档进行处理，因为那是 错误的文档不同于加载到其中的文档。
 获取&lt;iframe&gt;的window对象：
 通过索引获取：window.frames[0] —— 文档中的第一个 iframe 的 window 对象。 通过名称获取：window.frames.iframeName —— 获取 name=&ldquo;iframeName&rdquo; 的 iframe 的 window 对象。  iframe可以嵌套，相应的window对象会形成一个层次结构" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://onlyhy.github.io/posts/2021-12-17-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%85%B6%E4%BB%96%E4%B8%80/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-17T09:00:00+08:00" />
<meta property="article:modified_time" content="2021-12-17T09:00:00+08:00" />



    <title>
  现代JS教程[第三部分其他（一）] · oooonlyhy
</title>

    
      <link rel="canonical" href="http://onlyhy.github.io/posts/2021-12-17-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%85%B6%E4%BB%96%E4%B8%80/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css" integrity="sha256-2f3b/&#43;byfmmYXcX&#43;BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin="anonymous" media="screen" />
    

    

    

    

    

    <link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.91.0" />
  </head>

  
  
  <body class="preload-transitions colorscheme-light">
    

    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      oooonlyhy
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/">首页</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">归档</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/categories/">分类</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于我</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://onlyhy.github.io/posts/2021-12-17-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%E5%85%B6%E4%BB%96%E4%B8%80/">
              现代JS教程[第三部分其他（一）]
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2021-12-17T09:00:00&#43;08:00'>
                December 17, 2021
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              阅读时间：3 分钟
            </span>
          </div>
          <div class="authors">
    <i class="fa fa-user" aria-hidden="true"></i>
      <a href="/authors/onlyhy/">onlyhy</a></div>
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B/">现代JS教程</a></div>

          
        </div>
      </header>

      <div>
        
        <h3 id="frame和window">
  Frame和window
  <a class="heading-link" href="#frame%e5%92%8cwindow">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h5 id="弹窗和-window-的方法">
  弹窗和 window 的方法
  <a class="heading-link" href="#%e5%bc%b9%e7%aa%97%e5%92%8c-window-%e7%9a%84%e6%96%b9%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>阻止弹窗：如果弹窗是在用户触发的事件处理程序（如 onclick）之外调用的，大多数浏览器都会阻止此类弹窗。</p>
<p>如果弹窗是从 onclick 打开的，但是在 setTimeout 之后，弹窗在 Chrome 中会被打开，但是在 Firefox 中会被阻止。（Firefox 可以接受 2000ms 或更短的延迟）。</p>
<p><code>window.open(url, name, params)</code></p>
<ul>
<li>open调用会返回对新窗口的引用，可以用来操纵属性，修改内容等。</li>
<li>弹窗也可以使用<code>window.opener</code>来访问opener窗口（打开弹窗的窗口）。</li>
<li>因此窗口之间的连接是双向的：主窗口和弹窗之间相互引用。</li>
</ul>
<p><code>xxx.close()</code>关闭一个弹窗
<code>xxx.closed</code>检查窗口是否被关闭</p>
<p>focus/blur事件可以跟踪窗口的切换</p>
<h5 id="跨窗口通信">
  跨窗口通信
  <a class="heading-link" href="#%e8%b7%a8%e7%aa%97%e5%8f%a3%e9%80%9a%e4%bf%a1">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>同源：协议、域、端口都相同
非同源：无法访问该窗口中的内容，唯一例外是可以修改<code>location</code>但是无法读取location</p>
<p><strong>iframe</strong>
window：iframe.contentWindow
document：iframe.contentDocument(iframe.contentWindow.document的简写)</p>
<blockquote>
<p>不要对尚未加载完成的 iframe 的文档进行处理，因为那是 <strong>错误的文档</strong>不同于加载到其中的文档。</p>
</blockquote>
<p>获取<code>&lt;iframe&gt;</code>的window对象：</p>
<ul>
<li>通过索引获取：window.frames[0] —— 文档中的第一个 iframe 的 window 对象。</li>
<li>通过名称获取：window.frames.iframeName —— 获取 name=&ldquo;iframeName&rdquo; 的 iframe 的 window 对象。</li>
</ul>
<p>iframe可以嵌套，相应的window对象会形成一个层次结构</p>
<ul>
<li>window.frames —— “子”窗口的集合（用于嵌套的 iframe）。</li>
<li>window.parent —— 对“父”（外部）窗口的引用。</li>
<li>window.top —— 对最顶级父窗口的引用。（可用来判断当前文档是否在iframe中打开的）</li>
</ul>
<blockquote>
<ol>
<li>iframe可以添加 &ldquo;sandbox&rdquo; 特性表示<strong>禁止某些特性行为</strong>。</li>
<li>默认情况下，sndbox 会为iframe强制实施“不同来源”的策略</li>
<li>空的&quot;sandbox&quot;特性会施加最严格的限制，可以用一个以空格分隔的列表，列出要移除的限制。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe">官方手册</a></li>
</ol>
</blockquote>
<p><strong>document.domain</strong>
如果窗口的<strong>二级域相同</strong>，例如 john.site.com，peter.site.com 和 site.com（它们共同的二级域是 site.com），每个这样的窗口如果都执行：<code>document.domain = 'site.com';</code>那它们可以被当作<strong>同源</strong>来对待</p>
<p><strong>postMessage</strong></p>
<p><strong><code>postMessage</code></strong> 接口允许窗口之间相互通信，无论它们来自什么源。前提是双方必须均同意并调用相应的 JavaScript 函数。</p>
<ol>
<li>发送方调用 <code>targetWin.postMessage(data, targetOrigin)</code>。data是要发送的数据，targetOrigin表示只有源是targetOrigin的目标窗口才能获得消息，如果targetOrigin值不是：* ，浏览器就会检查。</li>
<li>目标窗使用addEventListener为message事件分配处理程序，event对象有三个属性：
<ul>
<li>data：传递来的数据</li>
<li>origin：发送方的源</li>
<li>source：对发送方窗口的引用（可以执行source.postMessage(&hellip;)）</li>
</ul>
</li>
</ol>
<h5 id="点击劫持攻击">
  点击劫持攻击
  <a class="heading-link" href="#%e7%82%b9%e5%87%bb%e5%8a%ab%e6%8c%81%e6%94%bb%e5%87%bb">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>允许恶意页面 以用户的名义 点击“受害网站”
原理：</p>
<ol>
<li>访问者被恶意页面吸引。怎样吸引的不重要。</li>
<li>页面上有一个看起来无害的链接（例如：“变得富有”或者“点我，超好玩！”）。</li>
<li>恶意页面在该链接上方放置了一个透明的<code>&lt;iframe&gt;</code>，其 src 来自于 facebook.com，这使得“点赞”按钮恰好位于该链接上面。这通常是通过 z-index 实现的。</li>
<li>用户尝试点击该链接时，实际上点击的是“点赞”按钮。</li>
</ol>
<p>防御方法：</p>
<ol>
<li><strong>X-Frame-Options</strong>
<code>X-Frame-Options</code>,可以允许或禁止在 frame 中显示页面。</li>
</ol>
<blockquote>
<ul>
<li>DENY 始终禁止在 frame 中显示此页面。</li>
<li>SAMEORIGIN 允许在和父文档同源的 frame 中显示此页面。</li>
<li>ALLOW-FROM domain 允许在来自给定域的父文档的 frame 中显示此页面。</li>
</ul>
</blockquote>
<ol start="2">
<li>用一个宽高都为100%的div覆盖页面，当window == top或者确定不需要保护时，再移除。</li>
</ol>
<h3 id="二进制数据文件">
  二进制数据，文件
  <a class="heading-link" href="#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e6%8d%ae%e6%96%87%e4%bb%b6">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h5 id="arraybuffer二进制数组">
  ArrayBuffer，二进制数组
  <a class="heading-link" href="#arraybuffer%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e7%bb%84">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>基本的二进制对象是 <strong><code>ArrayBuffer</code></strong> —— 对固定长度的连续内存空间的引用。与Array数组没有任何共同之处。
如要操作 ArrayBuffer，我们需要使用 <strong>“视图”对象</strong>（Unit8Array、Uint16Array、Uint32Array、Float64Array等）</p>
<p><strong>TypedArray</strong>
视图的通用术语是 <code>TypedArray</code>，享有同一种方法和属性。类似于常规数组：具有索引，并且是可迭代的。</p>
<p><strong>DataView</strong>
允许以任何格式访问任何偏移量（offset）的数据。
可以使用 .getUint8(i) 或 .getUint16(i) 之类的方法访问数据。我们在<strong>调用方法时选择格式</strong>，而不是在构造的时候。</p>
<p><img src="evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1070" alt="18b303c4ce736e5c3752445924ae2bfe.png"></p>
<h5 id="textdecoder-和-textencoder">
  TextDecoder 和 TextEncoder
  <a class="heading-link" href="#textdecoder-%e5%92%8c-textencoder">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>内建的 <code>TextDecoder</code> 对象在给定缓冲区（buffer）和编码格式（encoding）的情况下，能够将值读取到实际的 JavaScript 字符串中。
创建：let decoder = new TextDecoder([label], [options]);
解码：let str = decoder.decode([input], [options]);</p>
<p><code>TextEncoder</code> 做相反的事情 —— 将字符串转换为字节。
<code>let encoder = new TextEncoder();</code>只支持 utf-8 编码</p>
<blockquote>
<p><code>encode(str)</code> —— 从字符串返回 Uint8Array。
<code>encodeInto(str, destination)</code> —— 将 str 编码到 destination 中，该目标必须为 Uint8Array。</p>
</blockquote>
<h5 id="blob">
  Blob
  <a class="heading-link" href="#blob">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>Blob 由一个可选的字符串 type（通常是 MIME 类型）和 blobParts(一系列其他 Blob 对象，字符串和 BufferSource) 组成的“具有类型的二进制数据”。
<img src="evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1071" alt="77b2f6e74b120d9378106fee13d7c33a.png">
<strong>Blob对象是不可改变的。</strong>
<code>new Blob(blobParts, options);</code></p>
<blockquote>
<p>blobParts 是 Blob/BufferSource/String 类型的值的数组。<strong>必须是数组。</strong>
options可选对象：
&gt; * type —— Blob 类型，通常是 MIME 类型，例如 image/png
&gt; * endings —— 是否转换换行符，使 Blob 对应于当前操作系统的换行符（\r\n 或 \n）。默认为 &ldquo;transparent&rdquo;（啥也不做），不过也可以是 &ldquo;native&rdquo;（转换）</p>
</blockquote>
<p><strong>Blob可以用作<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>或其它标签的URL，来显示内容。</strong></p>
<blockquote>
<p>如模拟用户点击，自动下载。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">let link <span style="color:#f92672">=</span> document.createElement<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">)</span>;
link.download <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello.txt&#39;</span>;

let blob <span style="color:#f92672">=</span> new Blob<span style="color:#f92672">([</span><span style="color:#e6db74">&#39;Hello, world!&#39;</span><span style="color:#f92672">]</span>, <span style="color:#f92672">{</span>type: <span style="color:#e6db74">&#39;text/plain&#39;</span><span style="color:#f92672">})</span>;

link.href <span style="color:#f92672">=</span> URL.createObjectURL<span style="color:#f92672">(</span>blob<span style="color:#f92672">)</span>;

link.click<span style="color:#f92672">()</span>;

URL.revokeObjectURL<span style="color:#f92672">(</span>link.href<span style="color:#f92672">)</span>;
</code></pre></div><p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 URL → Blob 映射。</p>
<blockquote>
<p>但是有个副作用：如果创建一个 URL，那么即使不再需要该 Blob 了，它也会被挂在内存中。
<code>URL.revokeObjectURL(url)</code> 从内部映射中移除引用，因此允许 Blob 被删除（如果没有其他引用的话），并释放内存。（依具体情况删除）</p>
</blockquote>
<p><strong>Blob转换为base64</strong>
<code>URL.createObjectURL</code> 的一个替代方法是，将 Blob 转换为 base64-编码的字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">let link <span style="color:#f92672">=</span> document.createElement<span style="color:#f92672">(</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">)</span>;
link.download <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;hello.txt&#39;</span>;

let blob <span style="color:#f92672">=</span> new Blob<span style="color:#f92672">([</span><span style="color:#e6db74">&#39;Hello, world!&#39;</span><span style="color:#f92672">]</span>, <span style="color:#f92672">{</span>type: <span style="color:#e6db74">&#39;text/plain&#39;</span><span style="color:#f92672">})</span>;

let reader <span style="color:#f92672">=</span> new FileReader<span style="color:#f92672">()</span>;
reader.readAsDataURL<span style="color:#f92672">(</span>blob<span style="color:#f92672">)</span>; // 将 Blob 转换为 base64 并调用 onload

reader.onload <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
  link.href <span style="color:#f92672">=</span> reader.result; // data url
  link.click<span style="color:#f92672">()</span>;
<span style="color:#f92672">}</span>;
</code></pre></div><p>两种方法比较:</p>
<ol>
<li>URL.createObjectURL(blob)
<ul>
<li>如果介意内存，我们需要撤销（revoke）它们</li>
<li>直接访问 Blob，无需“编码/解码”</li>
</ul>
</li>
<li>Blob 转换为 data url
<ul>
<li>无需撤销（revoke）任何操作。</li>
<li>对大的 Blob 进行编码时，性能和内存会有损耗。</li>
</ul>
</li>
</ol>
<p><strong>Image转换为blob</strong>
可以创建一个图像（image）的、图像的一部分、或者甚至创建一个页面截图的 Blob。</p>
<ol>
<li>使用 <code>canvas.drawImage</code> 在 canvas 上绘制图像（或图像的一部分）。</li>
<li>调用 canvas 方法 <code>.toBlob(callback, format, quality)</code> 创建一个 Blob，并在创建完成后使用其运行 callback。</li>
</ol>
<p><strong>Blob转换为ArrayBuffer</strong>
使用FileReader从blob中获取最低级别的ArrayBuffer</p>
<h5 id="file-和-filereader">
  File 和 FileReader
  <a class="heading-link" href="#file-%e5%92%8c-filereader">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<p>File 对象继承自 Blob，并扩展了与文件系统相关的功能。
两种获取方式：</p>
<ol>
<li><code>new File(fileParts, fileName, [options])</code></li>
</ol>
<blockquote>
<ul>
<li>fileParts —— Blob/BufferSource/String 类型值的数组。</li>
<li>fileName —— 文件名字符串。</li>
<li>options —— 可选对象：lastModified —— 最后一次修改的时间戳（整数日期）。</li>
</ul>
</blockquote>
<ol start="2">
<li>从 <input type="file"> 或拖放或其他浏览器接口来获取文件。在这种情况下，file 将从操作系统（OS）获得 this 信息。</li>
</ol>
<blockquote>
<p>File继承自Blob，具有相同的属性
附加属性：name文件名，lastModified最后一次修改的时间戳</p>
</blockquote>
<p><strong>FileReader</strong> 是一个对象，其唯一目的是从 Blob（因此也从 File）对象中读取数据
<code>let reader = new FileReader(); // 没有参数</code>
主要方法：</p>
<blockquote>
<ol>
<li>readAsArrayBuffer(blob) —— 将数据读取为二进制格式的 ArrayBuffer。</li>
<li>readAsText(blob, [encoding]) —— 将数据读取为给定编码（默认为 utf-8 编码）的文本字符串。</li>
<li>readAsDataURL(blob) —— 读取二进制数据，并将其编码为 base64 的 data url。</li>
<li>abort() —— 取消操作。</li>
</ol>
</blockquote>
<p>读取过程中的事件：</p>
<blockquote>
<p>loadstart —— 开始加载。
progress —— 在读取过程中出现。
load —— 读取完成，没有 error。
abort —— 调用了 abort()。
error —— 出现 error。
loadend —— 读取完成，无论成功还是失败。</p>
</blockquote>
<p>读取完成后，读取结果：</p>
<blockquote>
<p>reader.result 是结果（如果成功）
reader.error 是 error（如果失败）</p>
</blockquote>
<blockquote>
<p>TIPS：
在 Web Workers 中可以使用 <strong>FileReaderSync</strong>，它的读取方法 read* 不会生成事件，但是会像常规函数那样返回一个结果。仅在 Web Worker 中可用，因为在读取文件的时候，同步调用会有延迟。</p>
</blockquote>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    ©
    
      2017 -
    
    2021
     OnlyHy 
    ·
    技术支持 <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

    </main>

    
      
      <script src="/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js" integrity="sha256-A7F3afT5GuNWZ&#43;HyocqMFvUFYlds&#43;Q/zKzF5kmkU2qU="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
