<!DOCTYPE html>
<html lang="zh-cn">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="OnlyHy">
    <meta name="description" content="类    class基本语法     new 会自动调用 constructor() 方法，因此我们可以在 constructor() 中初始化对象 类的方法之间没有逗号 在JS中，类是一种函数  class User { constructor(name) { this.name = name; } sayHi() { alert(this.name); } } // 佐证：User 是一个函数 alert(typeof User); // function  class User {&hellip;} 构造实际上做了如下的事：
 创建一个名为 User 的函数，该函数成为类声明的结果。该函数的代码来自于 constructor 方法（如果我们不编写这种方法，那么它就被假定为空）。 存储类中的方法到prototype，例如 User.prototype 中的 sayHi。   class不仅是语法糖，与纯函数之间存在重大差异    通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true，与普通函数不同，class只能通过 new 来调用，大多数 JavaScript 引擎中的类构造器的字符串表示形式都以 “class…” 开头 类的方法不可枚举，类定义将 &ldquo;prototype&rdquo; 中的所有方法的 enumerable 标志设置为 false 类总是使用 use strict。 在类构造中的所有代码都将自动进入严格模式   类可以在表达式中被定义，类似于命名函数表达式，类表达式也可以有名字，该名字仅在类内部可见 类中可以包括getter/setter，计算属性名称[&hellip;]等 class字段(field)：允许添加任何属性，会在每个独立对象上设置，而不是prototype上；类字段创建方法可以避免this的丢失问题click = () =&gt; { alert(this.">
    <meta name="keywords" content="onlyhy">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="现代JS教程[第一部分（四）]"/>
<meta name="twitter:description" content="类    class基本语法     new 会自动调用 constructor() 方法，因此我们可以在 constructor() 中初始化对象 类的方法之间没有逗号 在JS中，类是一种函数  class User { constructor(name) { this.name = name; } sayHi() { alert(this.name); } } // 佐证：User 是一个函数 alert(typeof User); // function  class User {&hellip;} 构造实际上做了如下的事：
 创建一个名为 User 的函数，该函数成为类声明的结果。该函数的代码来自于 constructor 方法（如果我们不编写这种方法，那么它就被假定为空）。 存储类中的方法到prototype，例如 User.prototype 中的 sayHi。   class不仅是语法糖，与纯函数之间存在重大差异    通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true，与普通函数不同，class只能通过 new 来调用，大多数 JavaScript 引擎中的类构造器的字符串表示形式都以 “class…” 开头 类的方法不可枚举，类定义将 &ldquo;prototype&rdquo; 中的所有方法的 enumerable 标志设置为 false 类总是使用 use strict。 在类构造中的所有代码都将自动进入严格模式   类可以在表达式中被定义，类似于命名函数表达式，类表达式也可以有名字，该名字仅在类内部可见 类中可以包括getter/setter，计算属性名称[&hellip;]等 class字段(field)：允许添加任何属性，会在每个独立对象上设置，而不是prototype上；类字段创建方法可以避免this的丢失问题click = () =&gt; { alert(this."/>

    <meta property="og:title" content="现代JS教程[第一部分（四）]" />
<meta property="og:description" content="类    class基本语法     new 会自动调用 constructor() 方法，因此我们可以在 constructor() 中初始化对象 类的方法之间没有逗号 在JS中，类是一种函数  class User { constructor(name) { this.name = name; } sayHi() { alert(this.name); } } // 佐证：User 是一个函数 alert(typeof User); // function  class User {&hellip;} 构造实际上做了如下的事：
 创建一个名为 User 的函数，该函数成为类声明的结果。该函数的代码来自于 constructor 方法（如果我们不编写这种方法，那么它就被假定为空）。 存储类中的方法到prototype，例如 User.prototype 中的 sayHi。   class不仅是语法糖，与纯函数之间存在重大差异    通过 class 创建的函数具有特殊的内部属性标记 [[IsClassConstructor]]: true，与普通函数不同，class只能通过 new 来调用，大多数 JavaScript 引擎中的类构造器的字符串表示形式都以 “class…” 开头 类的方法不可枚举，类定义将 &ldquo;prototype&rdquo; 中的所有方法的 enumerable 标志设置为 false 类总是使用 use strict。 在类构造中的所有代码都将自动进入严格模式   类可以在表达式中被定义，类似于命名函数表达式，类表达式也可以有名字，该名字仅在类内部可见 类中可以包括getter/setter，计算属性名称[&hellip;]等 class字段(field)：允许添加任何属性，会在每个独立对象上设置，而不是prototype上；类字段创建方法可以避免this的丢失问题click = () =&gt; { alert(this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://onlyhy.github.io/posts/2021-12-07-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9B%9B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-07T09:00:00+08:00" />
<meta property="article:modified_time" content="2021-12-07T09:00:00+08:00" />



    <title>
  现代JS教程[第一部分（四）] · oooonlyhy
</title>

    
      <link rel="canonical" href="http://onlyhy.github.io/posts/2021-12-07-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9B%9B/">
    

    <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css" integrity="sha256-2f3b/&#43;byfmmYXcX&#43;BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin="anonymous" media="screen" />
    

    

    

    

    

    <link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.91.0" />
  </head>

  
  
  <body class="preload-transitions colorscheme-light">
    

    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      oooonlyhy
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/">首页</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">归档</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/categories/">分类</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">关于我</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://onlyhy.github.io/posts/2021-12-07-%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E5%9B%9B/">
              现代JS教程[第一部分（四）]
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2021-12-07T09:00:00&#43;08:00'>
                December 7, 2021
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              阅读时间：2 分钟
            </span>
          </div>
          <div class="authors">
    <i class="fa fa-user" aria-hidden="true"></i>
      <a href="/authors/onlyhy/">onlyhy</a></div>
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/%E7%8E%B0%E4%BB%A3js%E6%95%99%E7%A8%8B/">现代JS教程</a></div>

          
        </div>
      </header>

      <div>
        
        <h3 id="类">
  类
  <a class="heading-link" href="#%e7%b1%bb">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h5 id="class基本语法">
  class基本语法
  <a class="heading-link" href="#class%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol>
<li>new 会自动调用 constructor() 方法，因此我们可以在 constructor() 中初始化对象</li>
<li><strong>类的方法之间没有逗号</strong></li>
<li>在JS中，类是一种函数</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">class User <span style="color:#f92672">{</span>
  constructor<span style="color:#f92672">(</span>name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> this.name <span style="color:#f92672">=</span> name; <span style="color:#f92672">}</span>
  sayHi<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> alert<span style="color:#f92672">(</span>this.name<span style="color:#f92672">)</span>; <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

// 佐证：User 是一个函数
alert<span style="color:#f92672">(</span>typeof User<span style="color:#f92672">)</span>; // <span style="color:#66d9ef">function</span>
</code></pre></div><blockquote>
<p>class User {&hellip;} 构造实际上做了如下的事：</p>
<ol>
<li>创建一个名为 User 的函数，该函数成为类声明的结果。该函数的代码来自于 constructor 方法（如果我们不编写这种方法，那么它就被假定为空）。</li>
<li>存储类中的方法到prototype，例如 User.prototype 中的 sayHi。</li>
</ol>
</blockquote>
<ol start="4">
<li>class不仅是语法糖，与纯函数之间存在重大差异</li>
</ol>
<blockquote>
<ol>
<li>通过 class 创建的函数具有特殊的内部属性标记 <strong>[[IsClassConstructor]]: true</strong>，与普通函数不同，class只能通过 <strong>new</strong> 来调用，大多数 JavaScript 引擎中的类构造器的字符串表示形式都以 “class…” 开头</li>
<li>类的方法<strong>不可枚举</strong>，类定义将 &ldquo;prototype&rdquo; 中的所有方法的 enumerable 标志设置为 false</li>
<li>类总是使用 <strong>use strict</strong>。 在类构造中的所有代码都将自动进入严格模式</li>
</ol>
</blockquote>
<ol start="5">
<li>类可以在表达式中被定义，类似于命名函数表达式，类表达式也可以有名字，该名字仅在类内部可见</li>
<li>类中可以包括getter/setter，计算属性名称[&hellip;]等</li>
<li>class字段(field)：允许添加任何属性，<strong>会在每个独立对象上设置，而不是prototype上</strong>；类字段创建方法可以避免this的丢失问题<code>click = () =&gt; { alert(this.value); }</code></li>
</ol>
<h5 id="类继承">
  类继承
  <a class="heading-link" href="#%e7%b1%bb%e7%bb%a7%e6%89%bf">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="8">
<li>一个类扩展另一个类，使用 <strong>&ldquo;extends&rdquo;</strong> 关键词</li>
<li>extends后可以指定任意表达式（当我们根据许多条件使用函数生成类，并继承它们时来说可能很有用）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#66d9ef">function</span> f<span style="color:#f92672">(</span>phrase<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">return</span> class <span style="color:#f92672">{</span>
    sayHi<span style="color:#f92672">()</span> <span style="color:#f92672">{</span> alert<span style="color:#f92672">(</span>phrase<span style="color:#f92672">)</span>; <span style="color:#f92672">}</span>
  <span style="color:#f92672">}</span>;
<span style="color:#f92672">}</span>

class User extends f<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">{}</span>

new User<span style="color:#f92672">()</span>.sayHi<span style="color:#f92672">()</span>; // Hello
</code></pre></div><ol start="10">
<li>可以重写方法用来完全替换父类方法；也可以在父类方法的基础上进行调整或扩展其功能，使用 <strong>”super“</strong> 关键字。</li>
</ol>
<blockquote>
<ol>
<li>执行 super.method(&hellip;) 来调用一个父类方法。</li>
<li>执行 super(&hellip;) 来调用一个父类 constructor（只能在我们的 constructor 中）</li>
<li>箭头函数没有super</li>
</ol>
</blockquote>
<ol start="11">
<li><strong>继承类的 constructor 必须调用 super(&hellip;)，并且一定要在使用 this 之前调用！！！</strong></li>
</ol>
<blockquote>
<p>原因：继承类的构造函数具有特殊的内部属性 <strong>[[ConstructorKind]]:&ldquo;derived&rdquo;</strong> ，它会影响new行为</p>
<ul>
<li>当通过 new 执行一个常规函数时，它将创建一个空对象，并将这个空对象赋值给 this</li>
<li>但是当继承的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作</li>
</ul>
</blockquote>
<blockquote>
<p>因此，派生的 constructor 必须调用 super 才能执行其父类（base）的 constructor，否则 this 指向的那个对象将不会被创建。并且会收到一个报错</p>
</blockquote>
<ol start="12">
<li>类被重写的字段被父类构造器使用时，父类构造器总是使用父类的字段，不会使用派生类重写的。（因为派生类在super()之后，类字段才会被初始化）</li>
</ol>
<blockquote>
<p>类字段初始化顺序：</p>
<ul>
<li>对于基类（还未继承任何东西的那种），在构造函数调用前初始化。</li>
<li>对于派生类，在 super() 后立刻初始化。</li>
</ul>
</blockquote>
<ol start="13">
<li>方法在内部的 [[HomeObject]] 属性中记住了它们的类/对象。这就是 super 如何解析父方法的。因此，将一个带有 super 的方法从一个对象复制到另一个对象是<strong>不安全</strong>的。</li>
</ol>
<h5 id="静态属性和静态方法">
  静态属性和静态方法
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e5%b1%9e%e6%80%a7%e5%92%8c%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="14">
<li>static静态方法，把一个方法赋值给类的<strong>函数本身</strong>，而<strong>不是赋给它的 &ldquo;prototype&rdquo;</strong> 。方法以static关键字开头，静态方法用于实现属于该类但不属于该类任何特定对象的函数。</li>
<li>静态方法也被用于与数据库相关的公共类，可以用于搜索/保存/删除数据库中的条目</li>
<li>静态属性也是以static关键字开头</li>
<li>静态属性和方法是<strong>可以被继承的</strong></li>
</ol>
<h5 id="私有的和受保护的属性和方法">
  私有的和受保护的属性和方法
  <a class="heading-link" href="#%e7%a7%81%e6%9c%89%e7%9a%84%e5%92%8c%e5%8f%97%e4%bf%9d%e6%8a%a4%e7%9a%84%e5%b1%9e%e6%80%a7%e5%92%8c%e6%96%b9%e6%b3%95">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="18">
<li>面向对象编程中，属性和方法可分为两组
<blockquote>
<ol>
<li>内部接口 —— 可以通过该类的其他方法访问，但不能从外部访问的方法和属性。</li>
<li>外部接口 —— 也可以从类的外部访问的方法和属性。</li>
</ol>
</blockquote>
</li>
<li>受保护的属性通常<strong>以下划线 _ 作为前缀</strong>，可通过set/get来控制保护属性，受保护的字段是是可以被继承的。</li>
<li>私有属性和方法应该<strong>以 # 开头</strong>。它们只在类的内部可被访问，无法从外部或从继承的类中访问</li>
<li>私有字段与公共字段不会发生冲突。我们可以同时拥有私有的 #waterAmount 和公共的 waterAmount 字段</li>
<li><strong>私有字段不能通过 this[name] 访问！！</strong></li>
</ol>
<h5 id="扩展内建类">
  扩展内建类
  <a class="heading-link" href="#%e6%89%a9%e5%b1%95%e5%86%85%e5%bb%ba%e7%b1%bb">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="23">
<li>内建的类，例如 Array，Map 等也都是可以扩展的</li>
<li>内建类相互之间<strong>不继承静态方法</strong>，例如Date继承自Object，但Date就没有Date.keys()这个方法，Date 和 Object 之间没有连结。它们是独立的，只有 Date.prototype 继承自 Object.prototype，仅此而已
<img src="evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1054" alt="982fe00d317f21adb19d0327e0205c7e.png"></li>
<li>可以给这个类添加一个特殊的静态 getter <strong>Symbol.species</strong>，返回 JavaScript 在内部用来在 map 和 filter 等方法中创建新实体的 constructor</li>
</ol>
<h5 id="类检查-instanceof">
  类检查 instanceof
  <a class="heading-link" href="#%e7%b1%bb%e6%a3%80%e6%9f%a5-instanceof">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="25">
<li><code>obj instanceof Class</code>，instanceof 操作符用于检查一个对象是否属于某个特定的 class。同时，它还考虑了继承</li>
<li><code>obj instanceof Class</code> 算法的执行过程
<blockquote>
<ol>
<li>如果有静态方法 Symbol.hasInstance，直接调用</li>
<li>否则，标准逻辑：检查 Class.prototype 是否等于 obj 的原型链中的原型之一</li>
</ol>
</blockquote>
</li>
<li><code>Object.prototype.toString.call（）</code>也可以用来得到字符串形式的类型</li>
<li>特殊的对象属性<code>Symbol.toStringTag</code> 可以自定义对象的 toString 方法的行为，会被包裹在[object &hellip;]里返回</li>
</ol>
<h5 id="mixin模式">
  Mixin模式
  <a class="heading-link" href="#mixin%e6%a8%a1%e5%bc%8f">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="29">
<li>Mixin — 是一个通用的面向对象编程术语：一个包含其他类的方法的类</li>
<li>JavaScript 不支持多重继承，但是可以通过将方法拷贝到原型中来实现 mixin，如<code>Object.assign(User.prototype, xxxMixin);</code></li>
<li>可以使用 mixin 作为一种通过添加多种行为（例如上文中所提到的事件处理）来扩充类的方法</li>
</ol>
<h3 id="错误处理">
  错误处理
  <a class="heading-link" href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h5 id="trycatch">
  try..catch
  <a class="heading-link" href="#trycatch">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol>
<li>try..catch 能工作，代码必须是<strong>可执行的</strong>，即必须是<strong>有效的</strong> JavaScript 代码（若代码包含语法错误，则无法正常工作），有效代码中出现的错误被称为“运行时的错误（runtime errors）”，有时被称为“异常（exceptions）”</li>
<li>try..catch<strong>同步工作</strong>，如果在“计划的（scheduled）”代码中发生异常，例如在 setTimeout 中，则 try..catch 不会捕获到异常，为了捕获到计划的（scheduled）函数中的异常，那么 try..catch 必须在这个函数内</li>
<li><strong>Error对象</strong>主要属性
<blockquote>
<ol>
<li>name：  Error 名称</li>
<li>message：  关于 error 的详细文字描述</li>
<li>stack：  当前的调用栈，用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息</li>
</ol>
</blockquote>
</li>
<li><strong>throw</strong> 操作符会抛出一个error对象，可以用内建的标准error的构造器来创建对象，Error，SyntaxError，ReferenceError，TypeError&hellip;，如<code>throw new SyntaxError(&quot;Incomplete data: no name&quot;);</code></li>
<li><strong>再次抛出：catch 应该只处理它知道的 error，并“抛出”所有其他 error</strong>
<blockquote>
<ol>
<li>Catch 捕获所有 error。</li>
<li>在 catch(err) {&hellip;} 块中，我们对 error 对象 err 进行分析。</li>
<li>如果我们不知道如何处理它，那我们就 throw err</li>
<li>被抛出的err可以被外部的 try..catch 结构（如果存在）捕获到，如果外部不存在这种结构，那么脚本就会被杀死</li>
</ol>
</blockquote>
</li>
</ol>
<h5 id="trycatchfinally">
  try..catch..finally
  <a class="heading-link" href="#trycatchfinally">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="6">
<li>如果finally存在，它在所有情况下都会被执行
<blockquote>
<ol>
<li>如果没有 error，try 之后执行</li>
<li>如果有 error，catch 之后执行</li>
<li>如果try中有return，那finally会在这个return 之前执行</li>
</ol>
</blockquote>
</li>
<li>window.onerror属性被赋值一个函数，将在发生未捕获的 error 时执行，可以用来提供错误日志等</li>
<li><code>window.onerror = function(message, url, line, col, error){};</code>
<blockquote>
<ol>
<li>message Error 信息</li>
<li>url 发生 error 的脚本的 URL</li>
<li>line,col 发生 error 处的代码的行号和列号</li>
<li>error Error 对象</li>
</ol>
</blockquote>
</li>
</ol>
<h5 id="自定义error扩展error">
  自定义Error，扩展Error
  <a class="heading-link" href="#%e8%87%aa%e5%ae%9a%e4%b9%89error%e6%89%a9%e5%b1%95error">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h5>
<ol start="9">
<li>可以从 Error 和其他内建的 error 类中进行继承，只需要注意 name 属性以及不要忘了调用 super</li>
<li>可以使用 instanceof 来检查特定的 error。但有时有来自第三方库的 error 对象，并且没有简单的方法来获取它的类。那么可以将 name 属性用于这一类的检查</li>
<li>包装异常是一项广泛应用的技术：用于处理低级别异常并创建高级别 error 而不是各种低级别 error 的函数。可以将低级别异常作为高级别的属性传递。</li>
</ol>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    ©
    
      2017 -
    
    2021
     OnlyHy 
    ·
    技术支持 <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

    </main>

    
      
      <script src="/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js" integrity="sha256-A7F3afT5GuNWZ&#43;HyocqMFvUFYlds&#43;Q/zKzF5kmkU2qU="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
