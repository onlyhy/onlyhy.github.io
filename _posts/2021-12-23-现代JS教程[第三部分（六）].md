### [正则表达式](https://zh.javascript.info/regular-expressions)
##### 模式（Patterns）和修饰符（flags）
正则表达式包含 **模式** 和 可选的 **修饰符**
创建正则表达式：
1. `regexp = new RegExp("pattern", "flags");` 允许使用变量动态地构造
2. `regexp = /pattern/gmi;` 不接受变量插入

**修饰符**
`i`、`g`、`m`、`u`、`y`

##### 字符类
* \d —— 数字 0 到 9。(digit)`[0-9]`
* \D —— 非数字。
* \s —— 空格符号，制表符 \t，换行符 \n和其它稀有字符 \v、\f、\r。(space)
* \S —— 除了 \s 。
* \w —— "单字"字符：拉丁字母，数字，下划线 '\_'。  (word)`[a-zA-Z0-9_]`
* \W —— 除了 \w。
* . —— 带有 's' 标志时表示“任何字符”包括换行符，否则为除换行符 \n之外的任何字符。

`[\s\S]`这种互补的类可以用来匹配“任何字符”

##### Unicode：修饰符 “u” 和 class \p{...}
修饰符 `u`：
1. 4 个字节长的字符被以正确的方式处理：被看成单个的字符，而不是 2 个 2 字节长的字符。
2. Unicode 属性可以被用于查找 \p{…}

查找具有某种属性的字符：`\p{...}`，必须要使用修饰符`u`。
查找16进制数字：`/x\p{Hex_Digit}\p{Hex_Digit}/u`
查找中文字符：`/\p{sc=Han}/gu`
查找货币：`/\p{Sc}/gu`  (`\p{Currency_Symbol}`缩写为`\p{Sc}`)
...

##### 锚点（Anchors)：字符串开始 ^ 和末尾 $
“锚点”：插入符号 `^` 匹配文本开头，美元符号 `$` 匹配文本末尾。
`^...$` 常被用于测试一个字符串是否完全匹配一个模式

##### Flag "m" — 多行模式
修饰符 `/.../m` 可以开启多行模式，会影响`^` 和 `$` 锚符的行为，不仅仅匹配文本的开始与结束，还匹配**每一行**的开始与结束。

##### 词边界：\b
三种不同的位置可作为词边界：
* 在字符串开头，如果第一个字符是单词字符 \w。
* 在字符串中的两个字符之间，其中一个是单词字符 \w，另一个不是。
* 在字符串末尾，如果最后一个字符是单词字符 \w。

`\b`既可以用于单词，也可以用于数字。如`/\b\d\d\b/`查找两位数
##### 转义，特殊字符
特殊字符：`[ \ ^ $ . | ? * + ( )`
把特殊字符作为常规字符来使用，只需要在它前面加个**反斜杠**即转义一个字符。

斜杠 `/` 虽然不是特殊符号，但是被用于在JS中开启和关闭正则匹配，所以也要转义，但是如果是用 `new RegExp`则不需要。

使用`new RegExp`需要**注意**：字符串的转义规则会使获得一个**没有反斜杠**的字符串，所以需要使用双斜杠`\\`来表示反斜杠 。

##### 集合和范围 [...]
方括号 […] 中的几个字符或者字符类意味着“搜索给定的字符中的**任意一个**”。
**集合**：如 `[abc]` ，查找 `a`、`b`、`c` 中的任意一个，且只会对应其中的一个。
**范围**：如`[a-z]`，匹配从 a 到 z 范围内的字母，`[\s\d]`表示空格字符或数字。

`[^...]`：排除范围，匹配所有除了给定的字符之外的任意字符。
在`[...]`中可以不转义特殊字符。

##### 量词 `+,*,?` 和 `{n}`
**量词**：形容所需要的数量的词。

**数量`{n}`** ：指出具体需要的数量。
    1. 如`\d{5}`，表示需要5位的数字
    2. 如`\d{3,5}`，表示需要位数为3至5位的数字
    3. `\d{3,}`，上限可以省略，表示查找大于或等于3位的数字

**缩写**：
* `+`：表示一个或多个，相当于{1,}
* `?`：表示零个或一个，相当于{0,1}，使符号变得可选
* `*`：表示零个或多个，相当于{0,}，即可以多次出现或不出现

##### 贪婪量词和惰性量词
贪婪模式下（默认情况），量词都会尽可能地重复多次。
```
let reg = /".+"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // "witch" and her "broom"
```
懒惰模式：量词 **“重复最少次数”**，通过在量词之后添加一个`'?'`来启用。
```
let reg = /".+?"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(reg) ); // witch, broom
```

> 懒惰模式不是万无一失的解决方法，还可以通过“微调”贪婪模式解决。

##### 捕获组
**捕获组**：模式的一部分用括号括起来`(...)`。

**嵌套组**：括号可以嵌套，形成**嵌套组**。

`str.match（regexp）`，**如果 regexp 没有 g 标志**，将查找第一个匹配并将它作为一个数组返回：

* 在索引 0 处：完全匹配。
* 在索引 1 处：第一个括号的内容。
* 在索引 2 处：第二个括号的内容。
* …等等…

**可选组**：即使组是可选的如：`(...)？`，且在匹配项中不存在，也存在相应的result数组项，值为`undefined`。


**matchAll**：当表达式有标志 `g`，`match` 方法不会返回捕获组的内容，需要用 `matchAll`。

`matchAll`与`match`的不同点：

1. 它返回的不是数组，而是一个可迭代的对象。
2. 当标志 g 存在时，它将每个匹配组作为一个数组返回。
3. 如果没有匹配项，则不返回 null，而是返回一个空的可迭代对象。

`matchAll`返回可迭代对象是一种**优化**，只有在U对返回的对象进行迭代时，才会进行搜索，可以根据需要去查找尽可能多的结果，可以不用查询全部的结果。

**命名组**：在开始括号之后立即放置 `?<name>`。
匹配的组都在`groups`属性中，可以通过`groups.name`来获取捕获组的结果。

**替换捕获组**：
`str.replace(regexp, replacement) `，用 replacement 替换 str 中匹配 regexp 的所有捕获组。这使用 ` $n ` 来完成，其中 `n `是组号，命名组号则使用`$<name>`。
如：
`str.replace(regexp, '$2, $1')`
`str.replace(regexp, '$<day>.$<month>.$<year>')`

**非捕获组**：在开头添加 `?:` 来排除组，这样这个捕获组的内容就不会出现在结果数组中。

##### 模式中的反向引用：\N 和 \k<name>;
**`\N`** ：可以在模式中引用一个组，`N`是组号。
`/(['"])(.*?)\1/g`：`\1`代表查找与第一（捕获）分组相同的文本，比如第一个捕获组匹配到的是 `"`双引号，那 `\1` 这里也只会匹配`"`双引号。

**`\k<name>`** ：也可以按照捕获组名来引用
`/(?<quote>['"])(.*?)\k<quote>/g`
##### 选择（OR）|
选择是正则表达式中的一个术语，实际上是一个简单的“或”，用`|`表示。
`[]`进行选择时是 **字符级别**，但`|`是 **表达式级别**。

一般用圆括号把选择部分括起来。
##### 前瞻断言与后瞻断言
前瞻肯定断言：`x(?=y)`，匹配 x, 仅在后面是 y 的情况

前瞻否定断言：`x(?!y)`，匹配 x, 但是仅在不被 y 跟随的情况下匹配成功

后瞻肯定断言：`(?<=y)x`, 匹配 x, 仅在前面是 y 的情况

后瞻否定断言：`(?<!y)x`, 匹配 x, 仅在前面不是 y 的情况

![07c5b6fc0a0c1ba2278df1b2389aaad4.png](evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1082)

> 环视断言括号中（前瞻和后瞻的通用名称）的内容不会成为匹配到的一部分结果。如果想要捕捉的话，需要将其包裹在一个另加的括号中。
> 如：`/\d+(?=(€|kr))/` €|kr 两边有额外的括号，这里`(€|kr)`会被一起捕获

##### 灾难性回溯
处理灾难性回溯（回溯陷阱）：
1. 重写正则表达式，尽可能减少其中排列组合的数量
2. 防止回溯（利用前瞻视角解决等）

##### 粘性标志 "y"，在位置处搜索
`y`标志允许在源字符串中的指定位置执行搜索。

当一个 regexp 被创建时，它的 `lastIndex` 是 0。
标记 `y` 使 `regexp.exec` 正好在 `lastIndex` 位置，而不是在它之前，也不是在它之后。

##### 正则表达式（RegExp）和字符串（String）的方法
1. `str.match(regexp)`
在字符串str中找到匹配regex的字符
* 不带有`g`，以**数组**的形式返回第一个匹配项，其中包含捕获分组和属性 index（匹配项的位置）、input（输入字符串，等于 str）。
* 带有`g`，将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息。
* 没有匹配项，无论是否带有`g`，都返回 **`null`** ，很重要！容易出错。
2. `str.matchAll(regexp)`
主要用来搜索所有**捕获组**的所有匹配项。

* 它返回包含匹配项的**可迭代对象**，而不是数组。我们可以用 Array.from 从中得到一个常规数组。
* 每个匹配项均以包含分组的数组形式返回（返回格式与不带 g 标记的 str.match 相同）。
* 如果没有结果，则返回的不是 null，而是一个**空的可迭代对象**。
3. `str.split(regexp|substr, limit)`
使用正则表达式（或子字符串）作为分隔符来分割字符串。
4. `str.search(regexp)`
返回**第一个匹配项**的位置，如果未找到，则返回 -1 。
    > **仅查找第一个！！**
5. `str.replace(str|regexp, str|func)`
用于**搜索和替换**的通用方法，是最有用的方法之一。它是搜索和替换字符串的瑞士军刀。
    > 当 replace 的第一个参数是字符串时，它**仅替换第一个匹配项**。
    > 如要找到所有的，应使用带 `g` 标记的正则表达式

第二个参数是替代字符串，可以使用特殊字符：
![ea06741efd25658a22c37b65d6d63fda.png](evernotecid://AD55C2FF-DB70-4AF5-9F57-2A1073AF7668/appyinxiangcom/17648251/ENResource/p1083)
第二个参数可以是一个函数，每次匹配都会调用，返回的值将作为替换字符串插入。
`func(match, p1, p2, ..., pn, offset, input, groups)`:
* match － 匹配项，
* p1, p2, ..., pn － 分组的内容（如有），
* offset － 匹配项的位置，
* input － 源字符串，
* groups － 所指定分组的对象(如有)。

6. `regexp.exec(str)`
返回字符串 str 中的 regexp 匹配项。与以前的方法不同，它是在正则表达式而不是字符串上调用的。
* 没有 `g`，返回的第一个匹配与 str.match(regexp) 完全相同。这没什么新的变化
* 有 `g`：
    1. 调用 regexp.exec(str) 会返回第一个匹配项，并将紧随其后的位置保存在属性 `regexp.lastIndex` 中。
    2. 下一次同样的调用会从位置 `regexp.lastIndex` 开始搜索，返回下一个匹配项，并将其后的位置保存在 `regexp.lastIndex` 中。
    3. ...以此类推
    4. 如果没有匹配项，则 regexp.exec 返回 `null`，并将 `regexp.lastIndex` 重置为 0
    
重复调用会挨个返回所有的匹配项。

> `lastIndex` 可以手动设置，将从给定位置开始搜索
> 如果正则带有标记 `y` ，搜索将精确地在 `regexp.lastIndex` 位置执行，不会再继续了


7. `regexp.test(str)`
查找匹配项，然后返回 `true/false` 表示是否存在。
如果带有 `g`，则 `regexp.test` 从 `regexp.lastIndex` 属性中查找，并更新此属性，就像 `regexp.exec` 一样。
