---
layout: post
title:  "Git常用命令笔记"
date:   2017-06-29 22:05:00 +00:00
categories: mood
---


#### 创建版本库
创建一个空目录

	$ mkdir learngit
	$ cd learngit
	$ pwd
	/Users/onlyhy/learngit

`pwd`用于显示当前目录

通过 `git init` 初始化

添加文件到Git仓库

1. `git add <file>` 可添加多个
2. `git commit` 完成

#### 时光机穿梭

###### 版本回退
提交修改命令与提交新文件一样是两个步骤

`git status`随时掌握工作区的状态

`git diff`可查看文件修改的内容

`HEAD`指向当前版本，`HEAD^`上一个版本，以此类推，简单化如`HEAD~100`

使用命令`git reset --hard commit_id`在版本之中穿梭

`git log` 查看提交历史，显示从最近到最远的提交日志，以确定要退回到哪个版本，加上`--pretty=oneline`参数后输出简洁点

`git reflog` 查看命令历史，确定要回到未来的哪个版本

###### 工作区和暂存区
`git add` 把要提交的所有修改放到暂存区（Stage）,`git commit` 一次性把暂存区的所有修改提交到分支。

###### 管理修改
每次修改，如果不`add`到暂存区，那就不会加入到`commit`中

###### 撤销修改
`git checkout --file`丢弃工作区中的修改
若不但改乱了文件还添加到了暂存区，想丢弃修改两个步骤

1. `git reset HEAD file`
2. `git checkout --file`

已经提交了不合适的修改到版本库想要撤销提交，参考**版本回退**一节

###### 删除文件

`git rm`用于删除一个文件，并`git commit` 文件从版本库中删除了
若不小心删错了，版本库中还有，则`git checkout --file`恢复

#### 远程仓库

###### 添加远程库

在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，让两个仓库远程同步。
在GitHub创建一个新的仓库，仓库名与本地已有仓库名一直，其他默认，创建。
可以从这个仓库克隆出新的仓库或者将一个已有的本地仓库与之关联，然后把本地的内容推送到GitHub仓库。
在本地learngit仓库下执行

	$ git remote add origin git@github.com:onlyhy/learngit.git

远程库的名字默认为origin，接下来可把本地库的所有内容推送到远程库上。

	$ git push -u origin master

由于远程库是空的，第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，远程库内容与本地一模一样。
只要本地作了提交，就`$git push origin master`将本地master分支的最新修改推送至GitHub

###### 从远程库克隆
GitHub创建新的仓库如gitskills后，`$ git clone git@github.com:onlyhy/gitskills.git`克隆到本地，GitHub的地址不止一个，有*https://*或者*git://*,*ssh*支持的原生*git*协议速度最快。

#### 分支管理

###### 创建与分支合并
Git里*master*分支是主分支，*HEAD*指向当前分支，*master*指向最新的提交，再用*HEAD*指向*master*，就能确定当前分支，以及当前分支的提交点。每次提交，*master*分支都会向前移动一步.
当创建新的分支，如*dev*，Git新建了一个指针*dev*，指向*master*相同的提交，再把*HEAD*指向*dev*，就表示当前分支在*dev*上,之后对工作区的修改和提交就是针对*dev*分支了。
当*dev*上的工作完成后可将它合并到*master*上，最简单就是把*master*指向*dev*的当前提交，完成合并。合并后可以删除*dev*分支，即将*dev*指针删掉。

查看分支：`git branch`

创建分支：`git branch <name>`

切换分支：`git checkout <name>`

创建+切换分支：`git checkout -b <name>`

合并某分支到当前分支：`git merge <name>`

删除分支：`git branch -d <name>`

实战：

	$ git checkout -b dev 
	Switched to a new branch 'dev'
	$ git branch
	* dev  //当前分支前有*号
  	  master
  	//做一个修改
  	Creating a new branch is quick.
  	//提交
  	$ git add readme.txt 
	$ git commit -m "branch test"
	[dev fec145a] branch test
	1 file changed, 1 insertion(+)
	//切回master分支
	$ git checkout master
	Switched to branch 'master'
	//合并指定分支到当前分支
	$ git merge dev
	Updating d17efd8..fec145a
	Fast-forward
	readme.txt |    1 +
 	1 file changed, 1 insertion(+)
 	//删除分支
 	$ git branch -d dev
	Deleted branch dev (was fec145a).
	$ git branch
	* master
	

###### 解决冲突
Git无法自动合并分支时，首先解决冲突，`git status`也会告诉我们冲突的文件，再提交，合并。
`git log --graph`可看到分支合并图

###### 分支管理策略
通常合并分支Git用的是*Fast forward*模式，但删除分支后，会丢掉分支信息。
`git merge --no-ff`该参数表示禁用`Fast forward`,则本次合并创建一个新的commit。合并后的历史有分支能看出来曾经做过合并。

###### Bug分支
通过一个新的临时分支来修复，修复后合并分支并删除临时分支。
`git stash`将现场工作储藏起来，等一会恢复现场再继续工作。
首先确定在哪个分支上修复bug,从它上面创建临时分支，修复完成后，切换回分支完成合并，删除临时分支。
`git stash list`查看工作现场

	$ git stash list
	stash@{0}: WIP on dev: 6224937 add merge

恢复现场有两个办法

1. `git stash apply`，恢复后，stash内容并不删除，需要用`git stash drop`删除
2. `git stash pop`，恢复的同时把stash内容也删除了

可多次`stash`,恢复的时候，先`git stash list`查看，再恢复指定的`stash`，如`git stash apply stash@{0}`







	






 